<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Biomed Res Int</journal-id><journal-id journal-id-type="iso-abbrev">Biomed Res Int</journal-id><journal-id journal-id-type="publisher-id">BMRI</journal-id><journal-title-group><journal-title>BioMed Research International</journal-title></journal-title-group><issn pub-type="ppub">2314-6133</issn><issn pub-type="epub">2314-6141</issn><publisher><publisher-name>Hindawi Publishing Corporation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">27747230</article-id><article-id pub-id-type="pmc">5056246</article-id><article-id pub-id-type="doi">10.1155/2016/4628592</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Parallel-SymD: A Parallel Approach to Detect Internal Symmetry in Protein Domains</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Jha</surname><given-names>Ashwani</given-names></name><xref ref-type="aff" rid="I1"/></contrib><contrib contrib-type="author"><name><surname>Flurchick</surname><given-names>K. M.</given-names></name><xref ref-type="aff" rid="I1"/></contrib><contrib contrib-type="author"><name><surname>Bikdash</surname><given-names>Marwan</given-names></name><xref ref-type="aff" rid="I1"/></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-5590-5403</contrib-id><name><surname>KC</surname><given-names>Dukka B.</given-names></name><xref ref-type="aff" rid="I1"/><xref ref-type="corresp" rid="cor1">
<sup>*</sup>
</xref></contrib></contrib-group><aff id="I1">Department of Computational Science and Engineering, North Carolina A&#x00026;T State University, Greensboro, NC 27411, USA</aff><author-notes><corresp id="cor1">*Dukka B. KC: <email>dbkc@ncat.edu</email></corresp><fn fn-type="other"><p>Academic Editor: Daniele D'Agostino</p></fn></author-notes><pub-date pub-type="ppub"><year>2016</year></pub-date><pub-date pub-type="epub"><day>26</day><month>9</month><year>2016</year></pub-date><volume>2016</volume><elocation-id>4628592</elocation-id><history><date date-type="received"><day>24</day><month>6</month><year>2016</year></date><date date-type="accepted"><day>25</day><month>8</month><year>2016</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2016 Ashwani Jha et al.</copyright-statement><copyright-year>2016</copyright-year><license license-type="open-access"><license-p>This is an open access article distributed under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><abstract><p>Internally symmetric proteins are proteins that have a symmetrical structure in their monomeric single-chain form. Around 10&#x02013;15% of the protein domains can be regarded as having some sort of internal symmetry. In this regard, we previously published SymD (symmetry detection), an algorithm that determines whether a given protein structure has internal symmetry by attempting to align the protein to its own copy after the copy is circularly permuted by all possible numbers of residues. SymD has proven to be a useful algorithm to detect symmetry. In this paper, we present a new parallelized algorithm called Parallel-SymD for detecting symmetry of proteins on clusters of computers. The achieved speedup of the new Parallel-SymD algorithm scales well with the number of computing processors. Scaling is better for proteins with a larger number of residues. For a protein of 509 residues, a speedup of 63 was achieved on a parallel system with 100 processors.</p></abstract><funding-group><award-group><funding-source xlink:href="http://dx.doi.org/10.13039/100000001">National Science Foundation</funding-source><award-id>1429464</award-id></award-group><award-group><funding-source xlink:href="http://dx.doi.org/10.13039/100008521">North Carolina Agricultural and Technical State University</funding-source></award-group></funding-group></article-meta></front><body><sec id="sec1"><title>1. Introduction</title><p>Not only multimeric proteins and protein complexes, but also the repeating units in monomeric proteins are arranged in a symmetric manner. We previously reported a method called SymD [<xref rid="B1" ref-type="bibr">1</xref>] and a webserver [<xref rid="B2" ref-type="bibr">2</xref>] based on SymD to determine internally symmetric proteins. Using SymD [<xref rid="B1" ref-type="bibr">1</xref>], around 10% of SCOP 1.73 ASTRAL40 domain database [<xref rid="B3" ref-type="bibr">3</xref>] is determined to be internally symmetric. <xref ref-type="fig" rid="fig1"> Figure 1</xref> shows examples of a symmetric 7-bladed beta propeller.</p><p>In comparison to other existing algorithms, SymD has proven to be a robust algorithm to determine internal symmetry in proteins. On the other hand, the exponential increase in computer power has made it possible to perform complex matrix operations in much less time. Many techniques exist for detecting the internal symmetry in protein domains. Some techniques use the structure alignment program [<xref rid="B4" ref-type="bibr">4</xref>&#x02013;<xref rid="B8" ref-type="bibr">8</xref>] and others use periodic occurrence of repeats along the primary sequence [<xref rid="B9" ref-type="bibr">9</xref>&#x02013;<xref rid="B12" ref-type="bibr">12</xref>].</p><p>The SymD algorithm makes use of an alignment scan procedure where the original protein structure is aligned to copies of itself obtained by circular permutation of all possible numbers of residues. A webserver of SymD algorithm has also been made publicly available [<xref rid="B2" ref-type="bibr">2</xref>]. SymD has demonstrated its ability to find a large number of symmetric proteins across various protein folds. SymD performs quite well in terms of accuracy when compared to other protein symmetry detection algorithms. Some algorithms detect a specific domain within the protein structure really well, but when tested extensively with all domains they tend to perform poorly. But SymD performs remarkably well for all protein domains and particularly for beta propellers where it detects the protein symmetry with 100 percent accuracy. Despite its robustness, emerging problems in bioinformatics require dramatically faster methods of detecting internal symmetry in protein domains, and hence SymD requires improvement.</p><p>The large size of protein structures presents a challenge to commonly used symmetry detection algorithms. The time taken to compute the symmetry of protein structure increases significantly with the size of protein structure due to the huge number of matrix operations. In spite of being consistently accurate across all protein domains, SymD lags behind in terms of speed and scalability. With little increase in input size, the speed decreases drastically, and, moreover, it does not have the capability to scale over multiple processors and multiple cores.</p><p>To reduce the limitation of SymD, we have come up with a new parallel algorithm that basically uses the same SymD design at its core but extends its capability to multiple processors and distributed computing systems which in turn help SymD to utilize multiple processors available to improve the speed of computation.</p><p>The need of parallelization arises because of this increased computational time with respect to the size of protein structures. Conversely, contemporary computers have typically multiple computing units (cores) [<xref rid="B13" ref-type="bibr">13</xref>]. Although aligning the original structure with one copy of the circularly permuted structure can be done in a much lesser time, performing the alignment scan for all possible numbers of circularly permuted structures requires high computational time. Consequently, as the size of protein structure increases, faster symmetry detection methods are required to handle the increasing computational load.</p><p>The message passing interface (MPI) standard for communication in parallel computing offers a solution to this problem [<xref rid="B14" ref-type="bibr">14</xref>]. The central processing units (CPUs) of modern computers have multiple cores that are separately programmable and can, when used proficiently, offer a significant increase in computation speed over single CPUs [<xref rid="B15" ref-type="bibr">15</xref>]. Furthermore, parallelization has been applied effectively to many problems in bioinformatics [<xref rid="B16" ref-type="bibr">16</xref>, <xref rid="B17" ref-type="bibr">17</xref>].</p><p>In this article, we present Parallel-SymD, the parallelized SymD algorithm for detection of internal symmetry in protein domains. This new algorithm that detects symmetry in protein domains is especially suited to efficient execution on multiple CPUs and computer of varying power interconnected in a network, which are available in contemporary computing platforms or computing clouds. When detecting the symmetry of a protein that has 509 residues, Parallel-SymD is around 63 times faster compared to the existing SymD algorithm when run in a parallel system using 100 processors. We explain the SymD algorithm, provide the description of our new Parallel-SymD algorithm, and discuss the performance and comparison between the two algorithms.</p></sec><sec id="sec2"><title>2. Materials and Methods</title><p>We describe Parallel-SymD algorithm by describing in short the original SymD algorithm [<xref rid="B1" ref-type="bibr">1</xref>] followed by the detailed algorithmic description of the Parallel-SymD algorithm.</p><sec id="sec2.1"><title>2.1. Overview of SymD Algorithm</title><p>The SymD [<xref rid="B1" ref-type="bibr">1</xref>] algorithm works by performing the alignment scan between the original structure and copies of itself, circularly permuted by all possible numbers of residues. It finds the score that determines the symmetricity of the original structure. Briefly, the algorithm first makes a copy of the original structure and circularly permutes its residues at all positions from 1 to <italic>N</italic> &#x02212; 3, where <italic>N</italic> is the number of residues of the protein. The algorithm then finds the best non-self-structural alignment between the original and each of the <italic>N</italic> &#x02212; 3 permuted structures. This process is called the &#x0201c;<italic>alignment scan.</italic>&#x0201d; The best alignment with each permuted structure is obtained using the RSE algorithm [<xref rid="B18" ref-type="bibr">18</xref>], which iterates a two-step cycle. In the first step, the Kabsch algorithm [<xref rid="B19" ref-type="bibr">19</xref>, <xref rid="B20" ref-type="bibr">20</xref>] is used to optimally superimpose the two structures by minimizing the weighted sum of squares of the distances between aligned pairs of residues. Then, in the second step, optimal structure-based sequence alignment is obtained from the superimposed structures using the SE algorithm [<xref rid="B21" ref-type="bibr">21</xref>]. The two-step cycle is terminated when the procedure has converged or when a set number of cycles are finished. The final alignment reported is the one with the best score during the cycle. The <italic>Z</italic>-score [<xref rid="B1" ref-type="bibr">1</xref>] of the <italic>T</italic>-score, which is a weighted number of aligned residues, similar to the sum of the similarity matrices <italic>S</italic><sub><italic>ij</italic></sub> of Gerstein and Levitt [<xref rid="B22" ref-type="bibr">22</xref>, <xref rid="B23" ref-type="bibr">23</xref>], is finally reported.</p><p>In this regard, SymD outputs the <italic>N</italic> &#x02212; 3 alignment scores and also the position and orientation of the symmetry axis for each of the alignments. The information about the position and orientation of the symmetry axis is obtained from the transformation matrix. Finally, a protein is deemed to be symmetric if one of the <italic>Z</italic>-scores of the alignments is greater than the cut-off value (<italic>Z</italic>-score of 8 or 10). It has to be noted here that symmetricity is not exact and it depends on the scoring function and the cut-off value associated with the scoring function. In this regard, a comprehensive and systematic analysis of various scoring functions and a systematic determination of cut-off value are required. Furthermore, SymD can also provide information about repeating units in a symmetric protein.</p></sec><sec id="sec2.2"><title>2.2. Parallel-SymD Implementation</title><p>At the heart of the SymD algorithm is the &#x0201c;alignment scan&#x0201d; procedure that aligns the original structure with each of the <italic>N</italic> &#x02212; 3 permuted structures and finds the best non-self-structural alignment between the original and each of the <italic>N</italic> &#x02212; 3 permuted structures. Each of the iterations in the alignment scan procedure is<italic> independent</italic> and thus SymD algorithm is well suited for parallelization. Here, an iteration consists of finding the best non-self-structural alignment between the original and each of the <italic>N</italic> &#x02212; 3 permuted structures and calculating optimal structure-based sequence alignment from the superimposed structures using the SE algorithm [<xref rid="B21" ref-type="bibr">21</xref>] and then calculating the similarity score.</p><p>Parallelization of the SymD algorithm should be accomplished in such a way that the algorithm should automatically be able to share the workload equally among the available number of processors. If we increase the number of processors, it should again redistribute the workload so that each processor will have the same amount of workload.</p><p>Parallelization of the time-consuming alignment scan should be accomplished in such a way that it is equally efficient in single or parallel computing systems. This implies that the parallelization methodology must incorporate automatic balancing of computation. The alignment scan between original structure and the copy of circularly permuted structure of itself is<italic> independent</italic> for each permutation, and thus the algorithm is<italic> appropriate for parallelization</italic>. Parallelization can also be achieved on the level of single computing node but such approach is not effective on parallel and distributed computing platforms with a lot of interconnected nodes. Because the alignment scan procedure implies high ratio between computation time and communication time, it can be better parallelized on a task level [<xref rid="B15" ref-type="bibr">15</xref>]. The Parallel-SymD algorithm is depicted in <xref ref-type="fig" rid="fig2">Figure 2</xref>.</p><p>A parallel platform can be represented as a set of slave nodes with a single master node. Bookkeeping is implemented as a separate process that runs on the master node. Usually, the master bookkeeping process is much simpler that the alignment scan processes and master node can run concurrently with slave nodes.</p><p>This can be achieved by removing any hard coded area that restricts the number of processors and workloads from being shared. Instead of hard coding at the compilation time, we implement the program according to the following guidelines: (a) decide at runtime how and among how many processes should the workload be distributed; (b) as soon as a new processor is available, automatically redistribute the work share among the newly available resources.</p><p>Obviously, one must check that SymD and Parallel-SymD yield the same results. To achieve this, we start by assigning the roles for each processor as a master or slave and design our program in such a way that even though the computations are done in individual processor, the results are sent back to one place and final results are shown by one processor.</p><p>For accomplishing this, we assign the role of housekeeping to the master processor (i.e., processor with rank 0). The master processor will handle the decomposition of tasks into subtasks and mapping of those subtasks to other processors, collecting the results from each processor, and analyzing those local results and generating the final answer. In this regard, an iteration of &#x0201c;alignment scan&#x0201d; is run on slave nodes. The communication between processes is implemented using a standard MPI library and consists of master node sending the &#x0201c;specific number of iterations of alignment scan&#x0201d; to the slave node that will return the best <italic>Z</italic>-score for the alignment scans to the master node.</p><p>As soon as the master processor gets the input and the information about the total number of processors, it reads the input protein and calculates the total number of residues in the input protein. Based on the number of processors available, the master processor then decomposes the task. If the residues lengths are not exactly divisible by the number of processes, the last processes as per the rank will be loaded with little extra work. After the decomposition of the task into subtasks, the master processor goes on a waiting phase where it seeks results from each processor. Sometimes, a process may take a long time to carry out execution and another process may complete the execution in a short time. But process 0 will not continue executing and analyzing the results until and unless it receives the result from each processor.</p><p>Once the master processor collects all the <italic>N</italic> &#x02212; 3 alignment scores, it displays all the results. Finally, a protein is considered symmetric if the <italic>Z</italic>-score of the best of these alignments exceeds a certain cut-off value.</p><p>The program that activates the SymD algorithm is the same for all computing slave nodes and has two parts: first for supervising master process with process identification (ID) = 0 and second for the remaining of the slave processes. The communication between parallel processes is implemented using standard MPI library [<xref rid="B14" ref-type="bibr">14</xref>] and consists of a master node sending the circularly permuted structure and original structure to slave nodes that will return the symmetric scores between the two structures to the master node. Communication is short: for each alignment scan, only the matrices of the two structures are sent to slave nodes, and only the information regarding the optimal alignment is returned by each slave node to the master node. In addition, queues of permuted structures on the slave nodes serve as buffers providing slave nodes with work. Since the computation of symmetric scores involves huge matrix operations, the time lost on communication between processes is several orders of magnitude shorter than the computation time. Consequently, the restrictions posed by communication channel bandwidth and message latency are very low.</p><p>As the MPI is available in a standard form for most existing platforms [<xref rid="B14" ref-type="bibr">14</xref>], our approach is highly portable. The communication requirements are minimal and computational load is automatically balanced.</p></sec></sec><sec id="sec3"><title>3. Results and Discussion</title><p>To validate and assess the performance of the Parallel-SymD algorithm, we performed a series of computational experiments that are presented below. The computational experiments were performed on a CRAY XC30 system. This parallel computer system is composed of 6 CPU quad-socket 8-core Intel nodes and two CPU/GPU 10-core Intel nodes with 4 K40 NVidia GPU. The operating system is Linux Kernel, CRAY CLE based on SuSE SLES release 11.3. MPICH (version 2) was used and CRAY compilers were used to compile the source program. The nodes are connected with Aries Interconnect. Please refer to [<xref rid="B24" ref-type="bibr">24</xref>] for the details.</p><sec id="sec3.1"><title>3.1. Validation of Parallel-SymD Algorithm</title><p>In order to validate that the Parallel-SymD algorithm works, we ran a set of 2000 proteins of various lengths and compared the <italic>Z</italic>-scores using the SymD [<xref rid="B1" ref-type="bibr">1</xref>] and Parallel-SymD and plotted these scores in <xref ref-type="fig" rid="fig3">Figure 3</xref>. It can be observed from the figure that Parallel-SymD and SymD produce the same <italic>Z</italic>-score for a set of 2000 proteins which validates the notion that Parallel-SymD and SymD produce the same results. We also show in <xref ref-type="fig" rid="fig4">Figure 4</xref> the variation of computation time as the size of the protein increases in a single processor. Though not shown, it has to be noted that as the size of the protein increases (beyond 500 residues) the computation time increases polynomially.</p></sec><sec id="sec3.2"><title>3.2. Communication Time</title><p>Performance gain depends upon various factors like communication time (time taken for two processors to communicate, that is, sending and receiving messages), computation time (actual time taken for computation of solution), and protein size. If the protein size is increased, the communication time increases for a given processors number. For example, if we choose to use 20 processors, the communication time increases as we keep increasing the protein size.</p><p>A plot of communication time versus the number of residues of proteins for 20 processors is shown in <xref ref-type="fig" rid="fig5">Figure 5</xref>, which in general demonstrates that the communication time shows quadratic growth with increase in the number of residues.</p></sec><sec id="sec3.3"><title>3.3. Computation Time</title><p>We also examined the effects of increasing the protein size on the computation time of calculating the symmetricity of a given protein. We observed that computation time shows quadratic growth as the protein size increases when the processor count is kept constant (= 20). The results of this analysis are shown in <xref ref-type="fig" rid="fig6">Figure 6</xref>.</p><p>Apart from the number of residues or protein size, the communication time and computation time are also dependent on the number of processors used. If we vary the number of processors keeping the protein size constant, we could see how the communication time increases and computation time decreases as we increase the processor count.</p><p>
<xref ref-type="fig" rid="fig7">Figure 7(a)</xref> shows how the communication time and <xref ref-type="fig" rid="fig7">Figure 7(b)</xref> shows how the computation time vary as the number of processors is varied while keeping the protein size constant. We have executed this on five proteins of various lengths and each protein was run on CRAY XC30-AC parallel system using 20, 30, 40, 50, 60, 70, and 80 processors. It is interesting to note that, for smaller proteins, the computation time increases as the number of processors is increased. This is due to the fact that for smaller proteins the ratio of the cost of communication time increases compared to the computation cost. Computation time in general decreases when we increase the number of processors keeping the protein size constant.</p></sec><sec id="sec3.4"><title>3.4. Performance Gain</title><p>Next, we measured the speedup of the proposed parallelization on a number of proteins taken from ASTRAL40 dataset [<xref rid="B3" ref-type="bibr">3</xref>]. We have selected around 2500 proteins from the dataset to measure the impact of protein size on the performance of the Parallel-SymD algorithm.</p><p>We first ran the SymD algorithm on a single processor to find out the execution time <italic>T</italic><sub>1</sub> of the nonparallel version of the algorithm. Then, we ran the Parallel-SymD algorithm on 20, 30, 40, 50, 60, 70, 80, and 100 processors of a CRAY XC30-AC parallel computer system. We measured the execution time of Parallel-SymD <italic>T</italic><sub><italic>p</italic></sub> and calculated speedup [<xref rid="B16" ref-type="bibr">16</xref>] as <italic>S</italic> = <italic>T</italic><sub>1</sub>/<italic>T</italic><sub><italic>p</italic></sub>. The maximum theoretical speed also known as ideal speed is equal to (<italic>p</italic> &#x02212; 1) since only <italic>p</italic> &#x02212; 1 processors are involved in performing the computation.</p><p>We plotted the performance gain (speedup) when Parallel-SymD is run on different numbers of processors ranging from 20 to 80. The results are shown in Figures <xref ref-type="fig" rid="fig8">8(a)</xref>&#x02013;<xref ref-type="fig" rid="fig8">8(g)</xref>. It can be observed from the results that for the smaller protein of ~100 residues the speed does not increase when using 100 processors. Therefore, the smaller proteins should not be calculated on higher number of processors. The parallel scaling efficiency, which is defined as the ratio between measured speed up and ideal speedup, is in between 50% and 81%. It decreases with the number of computing nodes and increases with protein size. The speedup was close to 64 when used with 100 processors, and it was close to 55 when used with 80 processors and decreases as we decrease the number of processors. The proposed methodology is very appropriate for the network and cluster computing. Further increase of the speedup is possible by the parallelization on the level of symmetry detection algorithm itself, which will result in finer granularity of the problem and easier load-balancing of processors. In particular, we can parallelize the RSE routine that is the essential building block of the proposed symmetry detection algorithms. Future work includes exploring the efficiency of many-core and graphic processing unit (GPU) platforms in further parallelization approaches.</p><p>The advantage of the proposed Parallel-SymD is its ease of use and better performance, compared to naive parallelization. The only requirement is that the Parallel-SymD program is properly installed and that the master node is able to communicate with all slave nodes through the MPI library.</p></sec><sec id="sec3.5"><title>3.5. Postprocessing Time</title><p>We also plotted the time taken by the master node from the moment it receives data from the slave node to the point when it displays the result, postprocessing time. Since a single processor does the postprocessing, we have plotted the graph of postprocessing time against the protein size in <xref ref-type="fig" rid="fig9">Figure 9</xref>. It can be observed that postprocessing time is relatively insignificant compared to the computation time.</p></sec></sec><sec id="sec4"><title>4. Conclusions and Discussion</title><p>In this work, we presented a parallel strategy to determine internal symmetry in a protein called Parallel-SymD. As the number of proteins structures continues to grow, it becomes very important to understand and characterize the structural features of these proteins including internal symmetry of the protein. The proposed parallel algorithm has been implemented on distributed computing system environment. The experimental results show that the algorithm presents good scalability and a nearly linear speedup. With the use of 100 processing nodes, the system achieved a 65x speedup. Thus, the proposed parallel algorithm scales well with the number of processors, enabling high performance on parallel systems.</p><p>As observed from <xref ref-type="sec" rid="sec3">Section 3</xref>, Parallel-SymD helped achieve a huge amount of performance gain compared with the serial version of SymD. As the performance gain depends upon various factors like computation time, communication time, size of protein, and so forth, thus the performance gain does not necessarily increase in the same ratio as the number of processors for all protein sizes.</p><p>We have also characterized speedup of the algorithm by running the algorithm using 20, 30, 40, 50, 60, 70, 80, and 100 processors. Although we were not able to achieve the ideal speedup in each case (which should be 19, 29, 39, 49, 59, 69, 79, and 99 times, resp.) (total processors &#x02212; 1), however, we were able to achieve a nearly linear speedup. To be precise, in the case of 20 processors, we achieved performance gain closer to 81% of the ideal value. Similarly, in the case of 80 processors, we achieved performance gain closer to 74% of the ideal value.</p><p>Finally, Parallel-SymD approach is one of the first types of approaches to detect symmetricity in proteins which harnesses the massive parallel architecture of existing computational infrastructures. To facilitate the use of Parallel-SymD source code, an executable of the program can be obtained from the corresponding author.</p></sec></body><back><ack><title>Acknowledgments</title><p>The authors would like to acknowledge the Cray Computational Resources at North Carolina A&#x00026;T State University that was funded by NSF Grant 1429464. Dukka B. KC is partly supported by a startup grant from the Department of Computational Science &#x00026; Engineering at North Carolina A&#x00026;T State University. SymD was originally developed at Dr. Byungkook's Lab at the NIH. The authors would also like to acknowledge Dr. Byungkook Lee for mentoring Dukka B. KC at the NIH on symmetry detection.</p></ack><sec sec-type="COI-statement"><title>Competing Interests</title><p>The authors declare that they have no competing interests.</p></sec><ref-list><ref id="B1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>C.</given-names></name><name><surname>Basner</surname><given-names>J.</given-names></name><name><surname>Lee</surname><given-names>B.</given-names></name></person-group><article-title>Detecting internally symmetric protein structures</article-title><source><italic>BMC Bioinformatics</italic></source><year>2010</year><volume>11, article 303</volume><pub-id pub-id-type="doi">10.1186/1471-2105-11-303</pub-id><pub-id pub-id-type="other">2-s2.0-77953002925</pub-id></element-citation></ref><ref id="B2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tai</surname><given-names>C.-H.</given-names></name><name><surname>Paul</surname><given-names>R.</given-names></name><name><surname>Dukka</surname><given-names>K. C.</given-names></name><name><surname>Shilling</surname><given-names>J. D.</given-names></name><name><surname>Lee</surname><given-names>B.</given-names></name></person-group><article-title>SymD webserver: a platform for detecting internally symmetric protein structures</article-title><source><italic>Nucleic Acids Research</italic></source><year>2014</year><volume>42</volume><issue>1</issue><fpage>W296</fpage><lpage>W300</lpage><pub-id pub-id-type="doi">10.1093/nar/gku364</pub-id><pub-id pub-id-type="other">2-s2.0-84904814313</pub-id><pub-id pub-id-type="pmid">24799435</pub-id></element-citation></ref><ref id="B3"><label>3</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chandonia</surname><given-names>J.-M.</given-names></name><name><surname>Hon</surname><given-names>G.</given-names></name><name><surname>Walker</surname><given-names>N. S.</given-names></name><etal/></person-group><article-title>The ASTRAL compendium in 2004</article-title><source><italic>Nucleic Acids Research</italic></source><year>2004</year><volume>32</volume><fpage>D189</fpage><lpage>D192</lpage><pub-id pub-id-type="doi">10.1093/nar/gkh034</pub-id><pub-id pub-id-type="other">2-s2.0-0348129526</pub-id><pub-id pub-id-type="pmid">14681391</pub-id></element-citation></ref><ref id="B4"><label>4</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kinoshita</surname><given-names>K.</given-names></name><name><surname>Kidera</surname><given-names>A.</given-names></name><name><surname>Go</surname><given-names>N.</given-names></name></person-group><article-title>Diversity of functions of proteins with internal symmetry in spatial arrangement of secondary structural elements</article-title><source><italic>Protein Science</italic></source><year>1999</year><volume>8</volume><issue>6</issue><fpage>1210</fpage><lpage>1217</lpage><pub-id pub-id-type="doi">10.1110/ps.8.6.1210</pub-id><pub-id pub-id-type="other">2-s2.0-0033031012</pub-id><pub-id pub-id-type="pmid">10386871</pub-id></element-citation></ref><ref id="B5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abraham</surname><given-names>A.-L.</given-names></name><name><surname>Pothier</surname><given-names>J.</given-names></name><name><surname>Rocha</surname><given-names>E. P. C.</given-names></name></person-group><article-title>Alternative to homo-oligomerisation: the creation of local symmetry in proteins by internal amplification</article-title><source><italic>Journal of Molecular Biology</italic></source><year>2009</year><volume>394</volume><issue>3</issue><fpage>522</fpage><lpage>534</lpage><pub-id pub-id-type="doi">10.1016/j.jmb.2009.09.031</pub-id><pub-id pub-id-type="other">2-s2.0-70350742988</pub-id><pub-id pub-id-type="pmid">19769988</pub-id></element-citation></ref><ref id="B6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abraham</surname><given-names>A.-L.</given-names></name><name><surname>Rocha</surname><given-names>E. P. C.</given-names></name><name><surname>Pothier</surname><given-names>J.</given-names></name></person-group><article-title>Swelfe: a detector of internal repeats in sequences and structures</article-title><source><italic>Bioinformatics</italic></source><year>2008</year><volume>24</volume><issue>13</issue><fpage>1536</fpage><lpage>1537</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btn234</pub-id><pub-id pub-id-type="other">2-s2.0-46249097882</pub-id><pub-id pub-id-type="pmid">18487242</pub-id></element-citation></ref><ref id="B7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guerler</surname><given-names>A.</given-names></name><name><surname>Wang</surname><given-names>C.</given-names></name><name><surname>Knapp</surname><given-names>E.-W.</given-names></name></person-group><article-title>Symmetric structures in the universe of protein folds</article-title><source><italic>Journal of Chemical Information and Modeling</italic></source><year>2009</year><volume>49</volume><issue>9</issue><fpage>2147</fpage><lpage>2151</lpage><pub-id pub-id-type="doi">10.1021/ci900185z</pub-id><pub-id pub-id-type="other">2-s2.0-70349929992</pub-id><pub-id pub-id-type="pmid">19728738</pub-id></element-citation></ref><ref id="B8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shih</surname><given-names>E. S. C.</given-names></name><name><surname>Hwang</surname><given-names>M.-J.</given-names></name></person-group><article-title>Alternative alignments from comparison of protein structures</article-title><source><italic>Proteins: Structure, Function and Genetics</italic></source><year>2004</year><volume>56</volume><issue>3</issue><fpage>519</fpage><lpage>527</lpage><pub-id pub-id-type="doi">10.1002/prot.20124</pub-id><pub-id pub-id-type="other">2-s2.0-3142745171</pub-id></element-citation></ref><ref id="B9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Taylor</surname><given-names>W. R.</given-names></name><name><surname>Heringa</surname><given-names>J.</given-names></name><name><surname>Baud</surname><given-names>F.</given-names></name><name><surname>Flores</surname><given-names>T. P.</given-names></name></person-group><article-title>A Fourier analysis of symmetry in protein structure</article-title><source><italic>Protein Engineering, Design &#x00026; Selection</italic></source><year>2002</year><volume>15</volume><issue>2</issue><fpage>79</fpage><lpage>89</lpage><pub-id pub-id-type="doi">10.1093/protein/15.2.79</pub-id><pub-id pub-id-type="other">2-s2.0-0036221375</pub-id></element-citation></ref><ref id="B10"><label>10</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Murray</surname><given-names>K. B.</given-names></name><name><surname>Taylor</surname><given-names>W. R.</given-names></name><name><surname>Thornton</surname><given-names>J. M.</given-names></name></person-group><article-title>Toward the detection and validation of repeats in protein structure</article-title><source><italic>Proteins: Structure, Function, and Bioinformatics</italic></source><year>2004</year><volume>57</volume><issue>2</issue><fpage>365</fpage><lpage>380</lpage><pub-id pub-id-type="doi">10.1002/prot.20202</pub-id><pub-id pub-id-type="other">2-s2.0-4544298192</pub-id></element-citation></ref><ref id="B11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Murray</surname><given-names>K. B.</given-names></name><name><surname>Gorse</surname><given-names>D.</given-names></name><name><surname>Thornton</surname><given-names>J. M.</given-names></name></person-group><article-title>Wavelet transforms for the characterization and detection of repeating motifs</article-title><source><italic>Journal of Molecular Biology</italic></source><year>2002</year><volume>316</volume><issue>2</issue><fpage>341</fpage><lpage>363</lpage><pub-id pub-id-type="doi">10.1006/jmbi.2001.5332</pub-id><pub-id pub-id-type="other">2-s2.0-0036290642</pub-id><pub-id pub-id-type="pmid">11851343</pub-id></element-citation></ref><ref id="B12"><label>12</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Taylor</surname><given-names>W. R.</given-names></name></person-group><article-title>Protein structure comparison using iterated double dynamic programming</article-title><source><italic>Protein Science</italic></source><year>1999</year><volume>8</volume><issue>3</issue><fpage>654</fpage><lpage>665</lpage><pub-id pub-id-type="other">2-s2.0-0033011876</pub-id><pub-id pub-id-type="pmid">10091668</pub-id></element-citation></ref><ref id="B13"><label>13</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>David</surname><given-names>W.</given-names></name></person-group><source><italic>Tuning IBM System X Servers for Performance</italic></source><year>2007</year><publisher-loc>Poughkeepsie, NY, USA</publisher-loc><publisher-name>International Technical Support Organization</publisher-name></element-citation></ref><ref id="B14"><label>14</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Snir</surname><given-names>M.</given-names></name><name><surname>Otto</surname><given-names>S. W.</given-names></name><name><surname>Huss-Lederman</surname><given-names>S.</given-names></name><name><surname>Walker</surname><given-names>D. W.</given-names></name><name><surname>Dongarra</surname><given-names>J.</given-names></name></person-group><source><italic>MPI&#x02014;The Complete Reference</italic></source><year>1998</year><publisher-loc>Cambridge, Mass, USA</publisher-loc><publisher-name>MIT Press</publisher-name></element-citation></ref><ref id="B15"><label>15</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Akl</surname><given-names>S. G.</given-names></name></person-group><source><italic>Parallel Computation: Models and Methods</italic></source><year>1997</year><publisher-loc>Upper Saddle River, NJ, USA</publisher-loc><publisher-name>Prentice Hall</publisher-name></element-citation></ref><ref id="B16"><label>16</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bor&#x00161;tnik</surname><given-names>U.</given-names></name><name><surname>Miller</surname><given-names>B. T.</given-names></name><name><surname>Brooks</surname><given-names>B. R.</given-names></name><name><surname>Jane&#x0017e;i&#x0010d;</surname><given-names>D.</given-names></name></person-group><article-title>The distributed diagonal force decomposition method for parallelizing molecular dynamics simulations</article-title><source><italic>Journal of Computational Chemistry</italic></source><year>2011</year><volume>32</volume><issue>14</issue><fpage>3005</fpage><lpage>3013</lpage><pub-id pub-id-type="doi">10.1002/jcc.21882</pub-id><pub-id pub-id-type="other">2-s2.0-80052038598</pub-id><pub-id pub-id-type="pmid">21793007</pub-id></element-citation></ref><ref id="B17"><label>17</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Konc</surname><given-names>J.</given-names></name><name><surname>Depolli</surname><given-names>M.</given-names></name><name><surname>Trobec</surname><given-names>R.</given-names></name><name><surname>Rozman</surname><given-names>K.</given-names></name><name><surname>Jane&#x0017e;i&#x0010d;</surname><given-names>D.</given-names></name></person-group><article-title>Parallel-ProBiS: fast parallel algorithm for local structural comparison of protein structures and binding sites</article-title><source><italic>Journal of Computational Chemistry</italic></source><year>2012</year><volume>33</volume><issue>27</issue><fpage>2199</fpage><lpage>2203</lpage><pub-id pub-id-type="doi">10.1002/jcc.23048</pub-id><pub-id pub-id-type="other">2-s2.0-84866742028</pub-id><pub-id pub-id-type="pmid">22718529</pub-id></element-citation></ref><ref id="B18"><label>18</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>C.</given-names></name><name><surname>Tai</surname><given-names>C.-H.</given-names></name><name><surname>Lee</surname><given-names>B.</given-names></name></person-group><article-title>Iterative refinement of structure-based sequence alignments by Seed Extension</article-title><source><italic>BMC Bioinformatics</italic></source><year>2009</year><volume>10, article 210</volume><pub-id pub-id-type="doi">10.1186/1471-2105-10-210</pub-id><pub-id pub-id-type="other">2-s2.0-67949111155</pub-id></element-citation></ref><ref id="B19"><label>19</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kabsch</surname><given-names>W.</given-names></name></person-group><article-title>A solution for the best rotation to relate two sets of vectors</article-title><source><italic>Acta Crystallographica Section A</italic></source><year>1976</year><volume>32</volume><issue>5</issue><fpage>922</fpage><lpage>923</lpage><pub-id pub-id-type="doi">10.1107/S0567739476001873</pub-id></element-citation></ref><ref id="B20"><label>20</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kabsch</surname><given-names>W.</given-names></name></person-group><article-title>A discussion of the solution for the best rotation to relate two sets of vectors</article-title><source><italic>Acta Crystallographica Section A</italic></source><year>1978</year><volume>34</volume><issue>5</issue><fpage>827</fpage><lpage>828</lpage><pub-id pub-id-type="doi">10.1107/S0567739478001680</pub-id></element-citation></ref><ref id="B21"><label>21</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tai</surname><given-names>C.-H.</given-names></name><name><surname>Vincent</surname><given-names>J. J.</given-names></name><name><surname>Kim</surname><given-names>C.</given-names></name><name><surname>Lee</surname><given-names>B.</given-names></name></person-group><article-title>SE: an algorithm for deriving sequence alignment from a pair of superimposed structures</article-title><source><italic>BMC Bioinformatics</italic></source><year>2009</year><volume>10</volume><issue>supplement 1, article S4</issue><pub-id pub-id-type="doi">10.1186/1471-2105-10-s1-s4</pub-id><pub-id pub-id-type="other">2-s2.0-58649094598</pub-id></element-citation></ref><ref id="B22"><label>22</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gerstein</surname><given-names>M.</given-names></name><name><surname>Levitt</surname><given-names>M.</given-names></name></person-group><article-title>Comprehensive assessment of automatic structural alignment against a manual standard, the scop classification of proteins</article-title><source><italic>Protein Science</italic></source><year>1998</year><volume>7</volume><issue>2</issue><fpage>445</fpage><lpage>456</lpage><pub-id pub-id-type="other">2-s2.0-0031938039</pub-id><pub-id pub-id-type="pmid">9521122</pub-id></element-citation></ref><ref id="B23"><label>23</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Levitt</surname><given-names>M.</given-names></name><name><surname>Gerstein</surname><given-names>M.</given-names></name></person-group><article-title>A unified statistical framework for sequence comparison and structure comparison</article-title><source><italic>Proceedings of the National Academy of Sciences of the United States of America</italic></source><year>1998</year><volume>95</volume><issue>11</issue><fpage>5913</fpage><lpage>5920</lpage><pub-id pub-id-type="doi">10.1073/pnas.95.11.5913</pub-id><pub-id pub-id-type="other">2-s2.0-0032568649</pub-id><pub-id pub-id-type="pmid">9600892</pub-id></element-citation></ref><ref id="B24"><label>24</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Jha</surname><given-names>A. K.</given-names></name></person-group><source><italic>A parallel approach to detect internal symmetry in proteins [M.S. thesis]</italic></source><year>2015</year><publisher-name>North Carolina A&#x00026;T</publisher-name></element-citation></ref></ref-list></back><floats-group><fig id="fig1" orientation="portrait" position="float"><label>Figure 1</label><caption><p>Symmetric 7-bladed beta propeller. The black dot shows the axis of rotation.</p></caption><graphic xlink:href="BMRI2016-4628592.001"/></fig><fig id="fig2" orientation="portrait" position="float"><label>Figure 2</label><caption><p>Overview of Parallel-SymD algorithm. Process 0 acts as a master node. If the rank ID of a process is not 0, then it will wait to receive the workload from process 0. After process 0 divides the problem and sends it to the rest of the processes, then each processor independently solves the subproblem and generates the results that are then sent back to the master node. Finally, the master node displays the results.</p></caption><graphic xlink:href="BMRI2016-4628592.002"/></fig><fig id="fig3" orientation="portrait" position="float"><label>Figure 3</label><caption><p>Comparison of <italic>Z</italic>-score between SymD and Parallel-SymD using a set of 200 proteins.</p></caption><graphic xlink:href="BMRI2016-4628592.003"/></fig><fig id="fig4" orientation="portrait" position="float"><label>Figure 4</label><caption><p>Change in computation time as the size of the protein increases for a single processor. Results obtained from 200 randomly selected proteins of various lengths on a CRAY XC30-AC parallel system using a single processor. The trend line is a quadratic fit to the data.</p></caption><graphic xlink:href="BMRI2016-4628592.004"/></fig><fig id="fig5" orientation="portrait" position="float"><label>Figure 5</label><caption><p>Change in communication time as the size of the protein increases for a fixed number of processors (= 20). Results obtained from 200 randomly selected proteins of various lengths on a CRAY XC30-AC parallel system using 20 processors.</p></caption><graphic xlink:href="BMRI2016-4628592.005"/></fig><fig id="fig6" orientation="portrait" position="float"><label>Figure 6</label><caption><p>Change in computation time as the size of the protein increases for a fixed number of processors (= 20). The computation time measured is the actual time taken for computation. The results were obtained after executing 200 randomly selected proteins of various lengths on a CRAY XC30-AC parallel computer system using a constant processors number of 20.</p></caption><graphic xlink:href="BMRI2016-4628592.006"/></fig><fig id="fig7" orientation="portrait" position="float"><label>Figure 7</label><caption><p>(a) Variation in communication time as we keep increasing the processors number keeping the protein size constant. This was executed on CRAY XC30-AC on five randomly selected proteins of sizes 29, 107, 233, 360, and 509. (b) Variation in computation time as the number of processors increases keeping the protein size constant as executed on CRAY XC30-AC parallel system on 5 randomly selected proteins of sizes 29, 107, 233, 360, and 509.</p></caption><graphic xlink:href="BMRI2016-4628592.007"/></fig><fig id="fig8" orientation="portrait" position="float"><label>Figure 8</label><caption><p>Performance gain with respect to various sizes of protein for different numbers of processors (20, 30, 40, 50, 60, 70, 80, and 100) for 200 proteins of various sizes. Even though generally the performance gain increases with the increase in the number of processors, the gain depends on the size of the protein. For larger protein, performance gain is higher than for smaller protein.</p></caption><graphic xlink:href="BMRI2016-4628592.008"/></fig><fig id="fig9" orientation="portrait" position="float"><label>Figure 9</label><caption><p>Variation in postprocessing time with increase in protein size as performed on CRAY XC30-AC parallel system using 60 processors.</p></caption><graphic xlink:href="BMRI2016-4628592.009"/></fig></floats-group></article>